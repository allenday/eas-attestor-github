name: Validate Attestation

on:
  repository_dispatch:
    types: [validate-attestation]

jobs:
  validate:
    runs-on: ubuntu-latest
    environment: ${{ github.event.client_payload.network || 'sepolia' }}
    
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install validation dependencies
        run: |
          npm install ethers@6.13.4

      - name: Validate GitHub attestation
        id: validate
        run: |
          # Extract data from repository_dispatch payload
          DOMAIN="${{ github.event.client_payload.domain }}"
          IDENTIFIER="${{ github.event.client_payload.identifier }}"
          PROOF_URL="${{ github.event.client_payload.proofUrl }}"
          ETHEREUM_ADDRESS="${{ github.event.client_payload.ethereumAddress }}"
          CALLBACK_ID="${{ github.event.client_payload.callbackId }}"
          
          echo "🔍 Validating attestation for $IDENTIFIER@$DOMAIN"
          echo "📄 Proof URL: $PROOF_URL"
          echo "💼 Ethereum Address: $ETHEREUM_ADDRESS"
          
          # Create validation script
          cat > validate.js << 'EOF'
          const { ethers } = require('ethers');
          const https = require('https');
          
          async function validateAttestation() {
            const domain = process.env.DOMAIN;
            const identifier = process.env.IDENTIFIER;
            const proofUrl = process.env.PROOF_URL;
            const ethereumAddress = process.env.ETHEREUM_ADDRESS;
            const validatorPrivateKey = process.env.VALIDATOR_PRIVATE_KEY;
            
            try {
              // 1. Fetch gist content
              console.log('📥 Fetching gist content...');
              const gistContent = await fetchGistContent(proofUrl);
              
              // 2. Parse JSON from gist
              const attestationData = JSON.parse(gistContent);
              console.log('📋 Parsed attestation data');
              
              // 3. Verify the gist URL belongs to the claimed identifier
              if (!proofUrl.includes(`gist.github.com/${identifier}/`)) {
                throw new Error(`Gist URL does not belong to user ${identifier}`);
              }
              
              // 4. Verify signature matches Ethereum address
              const message = attestationData.message;
              const signature = attestationData.signature;
              const recoveredAddress = ethers.verifyMessage(message, signature);
              
              if (recoveredAddress.toLowerCase() !== ethereumAddress.toLowerCase()) {
                throw new Error(`Signature verification failed. Expected ${ethereumAddress}, got ${recoveredAddress}`);
              }
              
              console.log('✅ Signature verification passed');
              
              // 5. Generate validation signature
              const validatedAt = Math.floor(Date.now() / 1000);
              const wallet = new ethers.Wallet(validatorPrivateKey);
              const validatorAddress = wallet.address;
              
              // Create message to sign: keccak256(domain, identifier, proofUrl, ethereumAddress, validatedAt)
              const messageToSign = ethers.solidityPackedKeccak256(
                ["string", "string", "string", "address", "uint256"],
                [domain, identifier, proofUrl, ethereumAddress, validatedAt]
              );
              
              const validationSig = await wallet.signMessage(ethers.getBytes(messageToSign));
              
              console.log('✅ Validation signature generated');
              console.log(`validation_sig=${validationSig}`);
              console.log(`validated_at=${validatedAt}`);
              console.log(`validator=${validatorAddress}`);
              
              // Output for GitHub Actions
              console.log(`::set-output name=validation_sig::${validationSig}`);
              console.log(`::set-output name=validated_at::${validatedAt}`);
              console.log(`::set-output name=validator::${validatorAddress}`);
              console.log(`::set-output name=success::true`);
              
            } catch (error) {
              console.error('❌ Validation failed:', error.message);
              console.log(`::set-output name=success::false`);
              console.log(`::set-output name=error::${error.message}`);
            }
          }
          
          function fetchGistContent(url) {
            return new Promise((resolve, reject) => {
              // Convert gist URL to raw URL
              const rawUrl = url.replace('gist.github.com', 'gist.githubusercontent.com') + '/raw';
              
              https.get(rawUrl, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => resolve(data));
              }).on('error', reject);
            });
          }
          
          validateAttestation();
          EOF
          
          # Run validation
          node validate.js
          
        env:
          DOMAIN: ${{ github.event.client_payload.domain }}
          IDENTIFIER: ${{ github.event.client_payload.identifier }}
          PROOF_URL: ${{ github.event.client_payload.proofUrl }}
          ETHEREUM_ADDRESS: ${{ github.event.client_payload.ethereumAddress }}
          CALLBACK_ID: ${{ github.event.client_payload.callbackId }}
          VALIDATOR_PRIVATE_KEY: ${{ secrets.VALIDATOR_PRIVATE_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Store validation result
        if: always()
        run: |
          CALLBACK_ID="${{ github.event.client_payload.callbackId }}"
          
          if [ "${{ steps.validate.outputs.success }}" = "true" ]; then
            echo "✅ Validation successful for callback ID: $CALLBACK_ID"
            echo "🔐 Validation signature: ${{ steps.validate.outputs.validation_sig }}"
            echo "⏰ Validated at: ${{ steps.validate.outputs.validated_at }}"
            echo "👤 Validator: ${{ steps.validate.outputs.validator }}"
            
            # Create result file that dApp can fetch
            cat > validation_result.json << EOF
          {
            "success": true,
            "callbackId": "$CALLBACK_ID",
            "validationSig": "${{ steps.validate.outputs.validation_sig }}",
            "validatedAt": ${{ steps.validate.outputs.validated_at }},
            "validator": "${{ steps.validate.outputs.validator }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          
          else
            echo "❌ Validation failed for callback ID: $CALLBACK_ID"
            echo "💥 Error: ${{ steps.validate.outputs.error }}"
            
            # Create error result file
            cat > validation_result.json << EOF
          {
            "success": false,
            "callbackId": "$CALLBACK_ID",
            "error": "${{ steps.validate.outputs.error }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          
          fi
          
          echo "📄 Validation result stored for callback ID: $CALLBACK_ID"
          cat validation_result.json